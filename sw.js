const d="stories-cache-v1",o="/starter-project-with-vite",h=`${o}/offline.html`,f="v1",a=`${d}-${f}`,g=[`${o}/`,`${o}/index.html`,`${o}/src/scripts/app.js`,`${o}/styles/main.css`,`${o}/favicon.ico`,`${o}/manifest.json`,`${o}/offline.html`,`${o}/icon-72x72.png`,`${o}/icon-96x96.png`,`${o}/icon-128x128.png`,`${o}/icon-144x144.png`,`${o}/icon-152x152.png`,`${o}/icon-192x192.png`,`${o}/icon-384x384.png`,`${o}/icon-512x512.png`];self.addEventListener("message",e=>{e.data&&e.data.action==="skipWaiting"&&self.skipWaiting()});const r=async e=>{(await self.clients.matchAll({type:"window"})).forEach(n=>{n.postMessage(e)})},p=async()=>{try{const e=await fetch(`${o}/`);if(e.status>=200&&e.status<300)return await r({type:"ONLINE_STATUS",payload:{isOnline:!0}}),!0;throw new Error("Network response was not ok")}catch{return await r({type:"ONLINE_STATUS",payload:{isOnline:!1}}),!1}};setInterval(p,3e4);self.addEventListener("activate",e=>{e.waitUntil(p())});self.addEventListener("install",e=>{console.log(`[Service Worker] Installing version ${f}...`),self.skipWaiting(),e.waitUntil(caches.open(a).then(t=>(console.log("[Service Worker] Caching app shell and static assets"),t.addAll(g).then(()=>{console.log("[Service Worker] All assets have been cached")}).catch(n=>{console.error("[Service Worker] Failed to cache some assets:",n)}))))});self.addEventListener("activate",e=>{console.log("[Service Worker] Activating..."),e.waitUntil(caches.keys().then(t=>Promise.all(t.map(n=>{if(n!==d)return console.log("[Service Worker] Removing old cache:",n),caches.delete(n)})))),self.clients.claim()});const s=async e=>{try{const t=await fetch(e);return t.status===200&&await(await caches.open(a)).put(e,t.clone()),t}catch(t){throw console.error("Network request failed, trying cache",t),t}},c=async e=>{const n=await(await caches.open(a)).match(e);if(n)return n;try{return await s(e)}catch{return e.mode==="navigate"?caches.match(h):e.destination==="image"?new Response('<svg role="img" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><title>Image not available</title><path fill="currentColor" d="M21 5v6.59l-3-3.01-4 4.01-4-4-4 4-3-3.01L3 5c0-1.1.9-2 2-2h14c1.1 0 2 .9 2 2zm-3 6.42l3 3.01V19c0 1.1-.9 2-2 2H5c-1.1 0-2-.9-2-2v-6.58l3 2.99 4-4 4 4 4-4z"/></svg>',{headers:{"Content-Type":"image/svg+xml"}}):new Response("You are offline and this resource is not available in the cache.",{status:408,statusText:"Offline",headers:new Headers({"Content-Type":"text/plain"})})}};self.addEventListener("fetch",e=>{if(e.request.method!=="GET"||!e.request.url.startsWith("http"))return;const t=new URL(e.request.url);if(!(!t.origin.startsWith(self.location.origin)||t.protocol==="chrome-extension:")){if(e.request.mode==="navigate"){e.respondWith(s(e.request).catch(()=>c(e.request)));return}if(e.request.url.includes("/api/")){e.respondWith(s(e.request).catch(()=>caches.match(e.request)));return}e.respondWith(c(e.request)),navigator.onLine&&!e.request.url.includes("/api/")&&e.waitUntil(s(e.request).catch(console.error))}});async function u(){console.log("[Service Worker] Checking for updates...");try{const e=await self.clients.matchAll({type:"window",includeUncontrolled:!0});e&&e.length&&e.forEach(n=>{n.postMessage({type:"CHECKING_FOR_UPDATES",timestamp:new Date().toISOString()})});const t=await self.registration;return t.waiting?(console.log("[Service Worker] Update found (waiting)"),l(),!0):(await t.update(),t.installing?(console.log("[Service Worker] Update found (installing)"),t.installing.addEventListener("statechange",n=>{n.target.state==="installed"&&l()}),!0):(console.log("[Service Worker] No updates found"),!1))}catch(e){return console.error("[Service Worker] Error checking for updates:",e),!1}}function l(){self.clients.matchAll({type:"window",includeUncontrolled:!0}).then(e=>{e&&e.length&&e.forEach(t=>{t.postMessage({type:"UPDATE_AVAILABLE",message:"A new version is available!",timestamp:new Date().toISOString(),reloadOnUpdate:!0})})})}self.addEventListener("periodicsync",e=>{e.tag==="check-for-updates"&&(console.log("[Service Worker] Periodic sync for updates"),e.waitUntil(u()))});self.addEventListener("message",e=>{e.data&&e.data.type==="SKIP_WAITING"?self.skipWaiting():e.data&&e.data.type==="CHECK_FOR_UPDATES"&&u()});self.addEventListener("sync",e=>{console.log(`[Service Worker] Background sync event: ${e.tag}`),e.tag==="sync-data"&&e.waitUntil(w().then(()=>{console.log("[Service Worker] Background sync completed"),self.clients.matchAll({type:"window"}).then(t=>{t.forEach(n=>{n.postMessage({type:"SYNC_COMPLETED",message:"Your data has been synced with the server.",timestamp:new Date().toISOString()})})})}).catch(t=>{console.error("[Service Worker] Background sync failed:",t)}))});async function w(){return console.log("[Service Worker] Starting background sync"),new Promise(e=>{setTimeout(()=>{console.log("[Service Worker] Background sync completed successfully"),e()},2e3)})}self.addEventListener("push",e=>{var i;const t="Stories App",n={body:((i=e.data)==null?void 0:i.text())||"You have new updates!",icon:`${o}/icon-192x192.png`,badge:`${o}/icon-96x96.png`,vibrate:[100,50,100],data:{dateOfArrival:Date.now(),primaryKey:1}};e.waitUntil(self.registration.showNotification(t,n))});self.addEventListener("notificationclick",e=>{console.log("Notification click received.",e),e.notification.close(),e.waitUntil(clients.matchAll({type:"window"}).then(t=>{for(const n of t)if(n.url==="/"&&"focus"in n)return n.focus();if(clients.openWindow)return clients.openWindow("/")}))});self.addEventListener("push",e=>{var i;const t="Stories App",n={body:((i=e.data)==null?void 0:i.text())||"You have new updates!",icon:"/icon-192x192.png",badge:"/icon-192x192.png"};e.waitUntil(self.registration.showNotification(t,n))});self.addEventListener("notificationclick",e=>{e.notification.close(),e.waitUntil(clients.matchAll({type:"window"}).then(t=>{for(const n of t)if(n.url==="/"&&"focus"in n)return n.focus();if(clients.openWindow)return clients.openWindow("/")}))});
